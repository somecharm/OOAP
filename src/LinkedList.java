/*
abstract class LinkedList <T>

public const int CURSOR_NIL = 0; // курсор ещё не устанавливался
public const int CURSOR_OK = 1; // курсор корректно установлен
public const int CURSOR_ERR = 2; // список пуст

public const int PUT_OK = 1; // последняя put_right() или put_left() отработала нормально
public const int PUT_ERR = 2; // список пуст

public const int REMOVE_OK = 1; // последняя remove() отработала нормально
public const int REMOVE_ERR = 2; // список пуст

public const int REPLACE_OK = 1; // последняя replace() отработала нормально
public const int REPLACE_ERR = 2; // список пуст

public const int FIND_NIL = 0; // поиск не начат
public const int FIND_OK = 1; // последняя find() отработала нормально
public const int FIND_ERR = 2; // узел с заданным значением отсутствует в списке

public const int REMOVE_ALL_OK = 1; // последняя remove_all() отработала нормально
public const int REMOVE_ALL_ERR = 2; // в списке нет ни одного узла с заданным значением


// конструктор
// постусловие: создан новый пустой список
public LinkedList<T> LinkedList();

// команды:

// предусловие: список не пустой
// постусловие: курсор установлен на первый узел в списке
public void head();

// предусловие: список не пустой
// постусловие: курсор установлен на последний узел в списке
public void tail();

// предусловие: список не пустой
// постусловие: курсор сдвинут на один узел вправо
public void right();

// предусловие: список не пустой
// постусловие: в список вслед за текущим узлом вставлен новый узел с заданным значением
public void put_right(T value);

// предусловие: список не пустой
// постусловие: в список перед текущим узлом вставлен новый узел с заданным значением
public void put_left(T value);

// предусловие: список не пустой
// постусловие: из списка удален текущий узел (курсор смещается к правому соседу, если он есть, в противном случае курсор смещается к левому соседу, если он есть);
public void remove();

// постусловие: из списка удалены все значения
public void clear();

// постусловие: добавлен новый узел в хвост списка
public void add_tail(T value);

// предусловие: список не пустой
// постусловие: значение текущего узла заменено на заданное
public void replace(T value);

// предусловие: в списке содержится узел с заданным значением
// постусловие: курсор установлен на следующий узел с искомым значением (по отношению к текущему узлу)
public void find(T value);

// предусловие: в списке содержится хотя бы один узел с заданным значением
// постусловие: из списка удалены все узлы с заданным значением
public void remove_all(T value);

// запросы:

// предусловие: список не пустой
public T get(); //получает значение текущего узла

public int size(); // подсчитывает количество узлов в списке

public boolean is_head(); -- находится ли курсор в начале списка?

public boolean is_tail(); -- находится ли курсор в конце списка?

public boolean is_value(); -- установлен ли курсор на какой-либо узел в списке (по сути, непустой ли список).

// дополнительные запросы:
public int get_cursor_status(); // возвращает значение CURSOR_*
public int get_put_status(); // возвращает значение PUT_*
public int get_remove_status(); // возвращает значение REMOVE_*
public int get_replace_status(); // возвращает значение REPLACE_*
public int get_find_status(); // возвращает значение FIND_*
public int get_remove_all_status(); // возвращает значение REMOVE_ALL*

2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?

Если исходить из эффективной реализации, то операцию tail() лучше выполнять прямым доступом к хвостовому узлу со сложностью O(1).
Другим способом добраться до хвоста списка и установить на него курсор может быть right(), но в этом случае нужно будет
сдвигать курсор до хвоста в цикле со сложностью O(N), такую реализацию нельзя назвать эффективной.

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?

В старом шаблоне класса поиск возвращал первый попавшийся узел, начиная с головного узла списка. С его помощью
невозможно получить список всех узлов с заданным значением. Поэтому нужен был отдельный метод.
В АТД появилось понятие курсора, и теперь поиск всех узлов с заданным значением можно свести к операции find(),
которая "запоминает" последний найденный узел, устанавливая на нем курсор.
*/
